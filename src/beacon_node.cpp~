/*

ROS beacon_node.cpp - ~/catkin_ws/src/contraspect/src/beacon_node.cpp

Author: 
 Anis Koubaa, Gaitech EDU

*/

#include "ros/ros.h"
#include "ros/master.h"
#include "std_msgs/String.h"
#include <sstream>
#include <string>

bool isNodeRunning(const std::string& node_name);

// argv: unique_nodename xcoord ycoord zcoord
int main(int argc, char **argv)
{
        ROS_INFO("argc: %d, argv: %s, %s, %s, %s, %s", argc, argv[0], argv[1], argv[2], argv[3], argv[4]);

	// copy content of argv[1] into nodename variable, rest of argv into coord variables
	std::string nodename = argv[1];
	// checking if there exists a node running called nodename	
	if (isNodeRunning(nodename)) {
	  ROS_ERROR("Node with name '%s' is running.", nodename.c_str());
	  return 1;
	} else {
	  ROS_INFO("Initializing node with this name: %s", nodename.c_str());
	}
	ros::init(argc, argv, nodename.c_str());
	if (!ros::master::check()) {
	  ROS_ERROR("Failed to initialize ROS.");
	  return 1;
	}
	ros::NodeHandle n;
	ros::Publisher chatter_publisher = n.advertise<std_msgs::String>("triang", 1000);
	ros::Rate loop_rate(0.05); //1 message per 10 seconds
	
   int count = 0;
   while (ros::ok()) 
   {
       std_msgs::String msg;
       std::stringstream ss;
       ss << "beacon_node Triang Msg " << count;
       msg.data = ss.str();
       ROS_INFO("[%s] msg published to topic \"triang\": %s\n", nodename.c_str(), msg.data.c_str());
       chatter_publisher.publish(msg);
       ros::spinOnce(); 
       loop_rate.sleep();
       count++;
   }
   return 0;
}

// function to check if a node with a given name is running
bool isNodeRunning(const std::string& node_name) {
    std::vector<std::string> nodes;
    ROS_INFO("A");
    ros::master::getNodes(nodes);
    ROS_INFO("B");
    for (const auto& node : nodes) {
        if (node == node_name) {
            return true;
        }
    }

    return false;
}

/* 

Exit
 /media/george/3218A8F718A8BAED/Users/hajdu/BME/ONL/ROS-projects 

*/
